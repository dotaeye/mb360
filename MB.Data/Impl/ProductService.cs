// <autogenerated>
//   This file was generated by T4 code generator Entry.tt.
//   Any changes made to this file manually will be lost next time the file is regenerated.
// </autogenerated>

using System;
using System.Linq;
using SQ.Core.Data;
using MB.Data.Service;
using MB.Data.Models;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Data.Entity.Spatial;

namespace MB.Data.Impl
{
    public class ProductService : IProductService
    {
        #region Fields

        private readonly IRepository<Product> _ProductRepository;
        private readonly IRepository<ProductStorageQuantity> _ProductStorageQuantityRepository;
        private readonly IRepository<ProductSpecificationAttribute> _ProductSpecificationAttributeRepository;
        private readonly IRepository<Storage> _StorageRepository;
        private readonly IRepository<SpecificationAttributeOption> _SpecificationAttributeOptionRepository;
        #endregion

        #region Ctor

        public ProductService(IRepository<Product> ProductRepository,
            IRepository<ProductStorageQuantity> ProductStorageQuantityRepository,
            IRepository<ProductSpecificationAttribute> ProductSpecificationAttributeRepository,
            IRepository<Storage> StorageRepository,
            IRepository<SpecificationAttributeOption> SpecificationAttributeOptionRepository
           )
        {
            this._ProductRepository = ProductRepository;
            this._ProductStorageQuantityRepository = ProductStorageQuantityRepository;
            this._ProductSpecificationAttributeRepository = ProductSpecificationAttributeRepository;
            this._StorageRepository = StorageRepository;
            this._SpecificationAttributeOptionRepository = SpecificationAttributeOptionRepository;

        }
        #endregion

        public async Task<int> DeleteAsync(Product entity)
        {
            if (entity == null)
                throw new ArgumentNullException("Product");

            entity.Deleted = true;
            return await UpdateAsync(entity);
        }

        public async Task<Product> FindOneAsync(int Id)
        {
            if (Id == 0)
                return null;

            var entity = await _ProductRepository.GetByIdAsync(Id);
            return entity;
        }

        public IQueryable<Product> GetAll()
        {
            return _ProductRepository.Table;
        }

        public IPagedList<Product> GetPageList(int pageIndex, int pageSize)
        {
            var query = _ProductRepository.Table;
            query = query.OrderByDescending(a => a.Id);
            var result = new PagedList<Product>(query, pageIndex, pageSize);
            return result;
        }

        public async Task<int> InsertAsync(Product entity)
        {
            if (entity == null)
                throw new ArgumentNullException("Product");
            return await _ProductRepository.InsertAsync(entity);
        }

        public async Task<int> UpdateAsync(Product entity)
        {
            if (entity == null)
                throw new ArgumentNullException("Product");

            return await _ProductRepository.UpdateAsync(entity);
        }

        /// <summary>
        /// Search products
        /// </summary>
        /// <param name="filterableSpecificationAttributeOptionIds">The specification attribute option identifiers applied to loaded products (all pages)</param>
        /// <param name="pageIndex">Page index</param>
        /// <param name="pageSize">Page size</param>
        /// <param name="categoryIds">Category identifiers</param>
        /// <param name="manufacturerId">Manufacturer identifier; 0 to load all records</param>
        /// <param name="RoleType">会员类型</param>
        /// <param name="isAgreeActive">是否同意参与活动</param>
        /// <param name="featuredProducts">A value indicating whether loaded products are marked as featured (relates only to categories and manufacturers). 0 to load featured products only, 1 to load not featured products only, null to load all products</param>
        /// <param name="priceMin">Minimum price; null to load all records</param>
        /// <param name="priceMax">Maximum price; null to load all records</param>
        /// <param name="keywords">Keywords</param>
        /// <param name="filteredSpecs">Filtered product specification identifiers</param>
        /// <param name="orderBy">Order by</param>
        /// <param name="showHidden">A value indicating whether to show hidden records</param>
        /// <returns>Products</returns>
        public virtual IPagedList<Product> SearchProducts(
            out IList<int> filterableSpecificationAttributeOptionIds,
            bool loadFilterableSpecificationAttributeOptionIds,
            int pageIndex = 0,
            int pageSize = int.MaxValue,
            IList<int> categoryIds = null,
            int manufacturerId = 0,
            int carId = 0,
            int RoleId = 0,
            bool isAgreeActive = false,
            bool? featuredProducts = null,
            decimal? priceMin = null,
            decimal? priceMax = null,
            string keywords = null,
            IList<int> filteredSpecs = null,
            ProductSortingEnum orderBy = ProductSortingEnum.Position,
            DbGeography location = null,
            bool showHidden = false)
        {
            filterableSpecificationAttributeOptionIds = new List<int>();

            //validate "categoryIds" parameter
            if (categoryIds != null && categoryIds.Contains(0))
                categoryIds.Remove(0);


            //stored procedures aren't supported. Use LINQ

            #region Search products

            //products
            var query = _ProductRepository.Table;
            query = query.Where(p => !p.Deleted);

            //只有审核通过的才可以显示
            if (!showHidden)
            {
                query = query.Where(p => p.Status > (int)ProductStatus.Published);
            }


            //The function 'CurrentUtcDateTime' is not supported by SQL Server Compact. 

            if (priceMin.HasValue)
            {
                bool searchVipPrice = RoleId >= (int)RoleType.Member;
                //min price
                query = query.Where(p =>
                                    //特价之后要实现的
                                    //special price (specified price and valid date range)
                                    //((p.SpecialPrice.HasValue &&
                                    //  ((!p.SpecialPriceStartDateTimeUtc.HasValue ||
                                    //    p.SpecialPriceStartDateTimeUtc.Value < nowUtc) &&
                                    //   (!p.SpecialPriceEndDateTimeUtc.HasValue ||
                                    //    p.SpecialPriceEndDateTimeUtc.Value > nowUtc))) &&
                                    // (p.SpecialPrice >= priceMin.Value))
                                    //||
                                    //regular price (price isn't specified or date range isn't valid)
                                    (p.Price >= priceMin.Value) || (searchVipPrice && p.VipPrice >= priceMin.Value));


            }


            if (priceMax.HasValue)
            {
                bool searchVipPrice = RoleId >= (int)RoleType.Member;
                //max price
                query = query.Where(p =>
                                     //special price (specified price and valid date range)

                                     //regular price (price isn't specified or date range isn't valid)
                                     (p.Price <= priceMax.Value) || (searchVipPrice && p.VipPrice <= priceMax));
            }


            //searching by keyword
            if (!String.IsNullOrWhiteSpace(keywords))
            {
                query = query.Where(p => p.Name.Contains(keywords));
            }



            //category filtering
            if (categoryIds != null && categoryIds.Any())
            {
                query = query.Where(p => categoryIds.Contains(p.CategoryId));
            }
            if (isAgreeActive)
            {
                query = query.Where(p => p.isAgreeActive);
            }
            //manufacturer filtering
            if (manufacturerId > 0)
            {
                query = from p in query
                        from pm in p.ProductManufacturers.Where(pm => pm.ManufacturerId == manufacturerId)
                        where (!featuredProducts.HasValue || featuredProducts.Value == pm.IsFeaturedProduct)
                        select p;
            }

            if (carId > 0)
            {
                query = from p in query
                        from pm in p.ProductCarCate.Where(pc => pc.CarCateId == carId)
                        select p;
            }

            if (loadFilterableSpecificationAttributeOptionIds)
            {
                var querySpecs = from p in query
                                 join psa in _ProductSpecificationAttributeRepository.Table on p.Id equals psa.ProductId
                                 select psa.SpecificationAttributeOptionId;
                //only distinct attributes
                filterableSpecificationAttributeOptionIds = querySpecs.Distinct().ToList();
            }


            //search by specs
            if (filteredSpecs != null && filteredSpecs.Any())
            {
                var filteredAttributes = _SpecificationAttributeOptionRepository.Table
                    .Where(sao => filteredSpecs.Contains(sao.Id)).Select(sao => sao.SpecificationAttributeId).Distinct();

                query = query.Where(p => !filteredAttributes.Except
                                    (
                                        _SpecificationAttributeOptionRepository.Table.Where(
                                            sao => p.ProductSpecificationAttributes.Where(
                                                psa => filteredSpecs.Contains(psa.SpecificationAttributeOptionId))
                                            .Select(psa => psa.SpecificationAttributeOptionId).Contains(sao.Id))
                                        .Select(sao => sao.SpecificationAttributeId).Distinct()
                                    ).Any());
            }




            //only distinct products (group by ID)
            //if we use standard Distinct() method, then all fields will be compared (low performance)
            //it'll not work in SQL Server Compact when searching products by a keyword)
            query = from p in query
                    group p by p.Id
                    into pGroup
                    orderby pGroup.Key
                    select pGroup.FirstOrDefault();


            if (location != null)
            {

                var tempQuery = from p in query
                                join d in (from t in
                                               (from s in _StorageRepository.Table
                                                join psq in _ProductStorageQuantityRepository.Table on s.Id equals psq.StorageId
                                                select new { s, psq })
                                           group t by t.psq.ProductId into g
                                           select new
                                           {
                                               ProductId = g.Key,
                                               distance = g.Min(z => z.s.Location.Distance(location))
                                           }) on p.Id equals d.ProductId
                                select new
                                {
                                    p,
                                    d.distance
                                };

                var count = tempQuery.Count();
                var source = tempQuery.OrderBy(x => x.distance)

                    .Skip(pageIndex * pageSize).Take(pageSize).ToList();


                var products = source.Select(x => x.p).ToList(); ;
                foreach (var sr in source)
                {
                    var product = products.First(x => x.Id == sr.p.Id);
                    product.Distance = sr.distance;
                }

                var result = new PagedList<Product>(products, pageIndex, pageSize, count);

                return result;
            }
            else
            {


                //sort products
                if (orderBy == ProductSortingEnum.Position && categoryIds != null && categoryIds.Any())
                {
                    //category position
                    var firstCategoryId = categoryIds[0];
                    query = query.OrderBy(p => p.Category.DisplayOrder);
                }
                else if (orderBy == ProductSortingEnum.Position && manufacturerId > 0)
                {
                    //manufacturer position
                    query =
                        query.OrderBy(p => p.ProductManufacturers.FirstOrDefault(pm => pm.ManufacturerId == manufacturerId).DisplayOrder);
                }
                else if (orderBy == ProductSortingEnum.Position)
                {
                    //otherwise sort by name
                    query = query.OrderBy(p => p.Name);
                }
                else if (orderBy == ProductSortingEnum.NameAsc)
                {
                    //Name: A to Z
                    query = query.OrderBy(p => p.Name);
                }
                else if (orderBy == ProductSortingEnum.NameDesc)
                {
                    //Name: Z to A
                    query = query.OrderByDescending(p => p.Name);
                }
                else if (orderBy == ProductSortingEnum.PriceAsc)
                {
                    //Price: Low to High
                    query = query.OrderBy(p => p.Price);
                }
                else if (orderBy == ProductSortingEnum.PriceDesc)
                {
                    //Price: High to Low
                    query = query.OrderByDescending(p => p.Price);
                }
                else if (orderBy == ProductSortingEnum.CreatedOn)
                {
                    //creation date
                    query = query.OrderByDescending(p => p.CreateTime);
                }
                else
                {
                    //actually this code is not reachable
                    query = query.OrderBy(p => p.Name);
                }

                var products = new PagedList<Product>(query, pageIndex, pageSize);


                //return products
                return products;

            }



            #endregion

        }
    }
}
